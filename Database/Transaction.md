# Transaction（事务）

    是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。 事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。一个逻辑工作单元要成为事务，必须满足所谓的ACID（原子性、一致性、隔离性和持久性）属性。事务是数据库运行中的逻辑工作单位，由DBMS中的事务管理子系统负责事务的处理。

## 事务四大特性（ACID）

```
  1、Atomicity(原子性)
  2、Consistency（一致性）
  3、Isolation（隔离性）
  4、Durability（持久性）
```

## 事务属性定义

  * 传播方式
      ```
        传播行为规定了事务方法和事务方法发生嵌套调用时事务如何进行传播，即协调已经有事务标识的方法之间的发生调用时的事务上下文的规则（是否要有独立的事务隔离级别和锁）。通俗的理解就是，不同传播行为性事务调用是否会异常，主事务与嵌套事务提交、回滚机制。spring事务有7种传播行为
      ```

      ```
        1、PROPAGATION.REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置

        2、PROPAGATION.SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。

        3、PROPAGATION.MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。

        4、PROPAGATION.REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建一个独立的新事务，独立提交与回滚。

        5、PROPAGATION.NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。

        6、PROPAGATION.NEVER：以非事务方式执行，如果当前存在事务，则抛出异常

        7、PROPAGATION.NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作
      ```

      FAQ

      ```
        注解@Transactional默认的传播行为是:PROPAGATION.REQUIRED
      ```

  * 隔离级别

      ```
        并发环境下很容易引起事务的数据脏读(dirty read)、不可重复读(nonrepeatable read)、幻读(phantom read)
      ```

      | 隔离级别        | 含义                             |
      | ------------- |:--------------------------------:|
      | ISOLATION_DEFAULT      | 使用后端数据库默认的隔离级别|
      | ISOLATION_READ_UNCOMMITTED     | 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读      |  
      | ISOLATION_READ_COMMITTED | 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生      |  
      | ISOLATION_REPEATABLE_READ | 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生     |  
      | ISOLATION_SERIALIZABLE | 最高的隔离级别，完全服从ACID的隔离级别，确保阻止脏读、不可重复读以及幻读，也是最慢的事务隔离级别，因为它通常是通过完全锁定事务相关的数据库表来实现的     |  

      FAQ

      ```
        nonrepeatable read与phantom read差异在于，nonrepeatable read重修改，phantom read重增删。
      ```
  * 超时时间

      ```
        “事务超时”很好理解，需要给事务设定超时时间，不能让程序无休止等待，超出时间则回滚

        因为事务可能涉及对后端数据库的锁定，所以长时间的事务会不必要的占用数据库资源。事务超时就是事务的一个定时器，在特定时间内事务如果没有执行完毕，那么就会自动回滚，而不是一直等待其结束。
      ```
  * 回滚规则
  * 是否只读

    ```
      “只读事务”并不是一个强制选项，它只是一个“暗示”，提示数据库驱动程序和数据库系统，这个事务并不包含更改数据的操作，那么JDBC驱动程序和数据库就有可能根据这种情况对该事务进行一些特定的优化，比方说不安排相应的数据库锁，以减轻事务对数据库的压力，毕竟事务也是要消耗数据库的资源的。

      “只读事务”仅仅是一个性能优化的推荐配置而已，并非强制你要这样做不可，在事务设计阶段，可以提前设置来优化性能

      “只读事务”中执行数据修改操作，会报异常
    ```

## 脏读
    一事务对数据进行了增删改，但未提交，另一事务可以读取到未提交的数据。如果第一个事务这时候回滚了，那么第二个事务就读到了脏数据

## 不可重复读
    一个事务中发生了两次读操作，第一次读操作和第二次操作之间，另外一个事务对数据进行了修改，这时候两次读取的数据是不一致的

## 幻读
    第一个事务对一定范围的数据进行批量修改，第二个事务在这个范围增加一条数据，这时候第一个事务就会丢失对新增数据的修改

## FAQ
    1、隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。
    2、大多数的数据库默认隔离级别为 Read Commited，比如 SqlServer、Oracle
    3、少数数据库默认隔离级别为：Repeatable Read 比如： MySQL InnoDB
